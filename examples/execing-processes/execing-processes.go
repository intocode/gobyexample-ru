// В предыдущем примере мы рассмотрели
// [порождение внешних процессов](spawning-processes). Мы
// делаем это, когда нужен внешний процесс, доступный
// работающему процессу Go. Иногда мы просто хотим
// полностью заменить текущий процесс Go другим (возможно,
// не Go) процессом. Для этого используем реализацию Go
// классической функции
// <a href="https://en.wikipedia.org/wiki/Exec_(operating_system)"><code>exec</code></a>.

package main

import (
	"os"
	"os/exec"
	"syscall"
)

func main() {

	// Для нашего примера выполним exec для `ls`. Go требует
	// абсолютный путь к бинарному файлу, который хотим
	// выполнить, поэтому используем `exec.LookPath` для его
	// поиска (вероятно, `/bin/ls`).
	binary, lookErr := exec.LookPath("ls")
	if lookErr != nil {
		panic(lookErr)
	}

	// `Exec` требует аргументы в виде среза (в отличие
	// от одной большой строки). Дадим `ls` несколько
	// распространённых аргументов. Обрати внимание, что
	// первым аргументом должно быть имя программы.
	args := []string{"ls", "-a", "-l", "-h"}

	// `Exec` также нужен набор [переменных окружения](environment-variables)
	// для использования. Здесь мы просто передаём наше
	// текущее окружение.
	env := os.Environ()

	// Вот фактический вызов `syscall.Exec`. Если этот вызов
	// успешен, выполнение нашего процесса закончится здесь
	// и будет заменено процессом `/bin/ls -a -l -h`.
	// Если есть ошибка, получим возвращаемое значение.
	execErr := syscall.Exec(binary, args, env)
	if execErr != nil {
		panic(execErr)
	}
}
