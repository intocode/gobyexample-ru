// В ходе выполнения программы часто нужно создавать
// данные, которые не нужны после завершения программы.
// *Временные файлы и директории* полезны для этой цели,
// поскольку они не засоряют файловую систему со временем.

package main

import (
	"fmt"
	"os"
	"path/filepath"
)

func check(e error) {
	if e != nil {
		panic(e)
	}
}

func main() {

	// Самый простой способ создать временный файл — вызвать
	// `os.CreateTemp`. Он создаёт файл *и* открывает его
	// для чтения и записи. Мы передаём `""` как первый
	// аргумент, поэтому `os.CreateTemp` создаст файл
	// в директории по умолчанию для нашей ОС.
	f, err := os.CreateTemp("", "sample")
	check(err)

	// Выводим имя временного файла. На Unix-подобных ОС
	// директорией скорее всего будет `/tmp`. Имя файла
	// начинается с префикса, переданного вторым аргументом
	// в `os.CreateTemp`, а остальное выбирается автоматически,
	// чтобы параллельные вызовы всегда создавали разные имена.
	fmt.Println("Temp file name:", f.Name())

	// Удаляем файл после завершения работы. ОС скорее всего
	// сама удалит временные файлы через некоторое время,
	// но хорошей практикой является делать это явно.
	defer os.Remove(f.Name())

	// Можем записать некоторые данные в файл.
	_, err = f.Write([]byte{1, 2, 3, 4})
	check(err)

	// Если мы планируем создавать много временных файлов,
	// лучше создать временную *директорию*. Аргументы
	// `os.MkdirTemp` такие же, как у `CreateTemp`, но он
	// возвращает *имя* директории, а не открытый файл.
	dname, err := os.MkdirTemp("", "sampledir")
	check(err)
	fmt.Println("Temp dir name:", dname)

	defer os.RemoveAll(dname)

	// Теперь можем создавать имена временных файлов,
	// добавляя к ним префикс нашей временной директории.
	fname := filepath.Join(dname, "file1")
	err = os.WriteFile(fname, []byte{1, 2}, 0666)
	check(err)
}
