// Часто нам нужно выполнить код Go в определённый момент
// в будущем или повторять с некоторым интервалом.
// Встроенные возможности Go — _таймеры_ и _тикеры_ —
// делают обе эти задачи простыми. Сначала рассмотрим
// таймеры, а затем [тикеры](tickers).

package main

import (
	"fmt"
	"time"
)

func main() {

	// Таймеры представляют одиночное событие в будущем.
	// Ты указываешь таймеру, сколько нужно подождать,
	// и он предоставляет канал, в который придёт уведомление
	// в нужный момент. Этот таймер будет ждать 2 секунды.
	timer1 := time.NewTimer(2 * time.Second)

	// `<-timer1.C` блокируется на канале таймера `C`,
	// пока тот не отправит значение, указывающее на то,
	// что таймер сработал.
	<-timer1.C
	fmt.Println("Timer 1 fired")

	// Если тебе просто нужно подождать, можно использовать
	// `time.Sleep`. Одна из причин, по которой таймер
	// может быть полезен — возможность отменить его
	// до срабатывания. Вот пример этого.
	timer2 := time.NewTimer(time.Second)
	go func() {
		<-timer2.C
		fmt.Println("Timer 2 fired")
	}()
	stop2 := timer2.Stop()
	if stop2 {
		fmt.Println("Timer 2 stopped")
	}

	// Даём `timer2` достаточно времени, чтобы сработать,
	// если бы он собирался, чтобы показать, что он
	// действительно остановлен.
	time.Sleep(2 * time.Second)
}
