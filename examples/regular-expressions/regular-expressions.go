// Go предоставляет встроенную поддержку [регулярных выражений](https://en.wikipedia.org/wiki/Regular_expression).
// Вот несколько примеров типичных задач, связанных с регулярными
// выражениями в Go.

package main

import (
	"bytes"
	"fmt"
	"regexp"
)

func main() {

	// Проверяем, соответствует ли паттерн строке.
	match, _ := regexp.MatchString("p([a-z]+)ch", "peach")
	fmt.Println(match)

	// Выше мы использовали строковый паттерн напрямую, но для
	// других задач с регулярными выражениями нужно скомпилировать
	// (`Compile`) оптимизированную структуру `Regexp`.
	r, _ := regexp.Compile("p([a-z]+)ch")

	// Для этих структур доступно множество методов. Вот
	// тест на совпадение, как мы видели ранее.
	fmt.Println(r.MatchString("peach"))

	// Находит совпадение для регулярного выражения.
	fmt.Println(r.FindString("peach punch"))

	// Также находит первое совпадение, но возвращает
	// начальный и конечный индексы совпадения вместо
	// совпавшего текста.
	fmt.Println("idx:", r.FindStringIndex("peach punch"))

	// Варианты `Submatch` включают информацию как о совпадениях
	// со всем паттерном, так и о подсовпадениях внутри них.
	// Например, это вернёт информацию и для `p([a-z]+)ch`,
	// и для `([a-z]+)`.
	fmt.Println(r.FindStringSubmatch("peach punch"))

	// Аналогично, это вернёт информацию об индексах
	// совпадений и подсовпадений.
	fmt.Println(r.FindStringSubmatchIndex("peach punch"))

	// Варианты `All` этих функций применяются ко всем
	// совпадениям во входных данных, а не только к первому.
	// Например, чтобы найти все совпадения для регулярного выражения.
	fmt.Println(r.FindAllString("peach punch pinch", -1))

	// Варианты `All` доступны и для других функций,
	// которые мы видели выше.
	fmt.Println("all:", r.FindAllStringSubmatchIndex(
		"peach punch pinch", -1))

	// Передача неотрицательного целого числа в качестве второго
	// аргумента этих функций ограничит количество совпадений.
	fmt.Println(r.FindAllString("peach punch pinch", 2))

	// В примерах выше мы использовали строковые аргументы
	// и имена вроде `MatchString`. Можно также передавать
	// аргументы типа `[]byte` и убрать `String` из имени функции.
	fmt.Println(r.Match([]byte("peach")))

	// При создании глобальных переменных с регулярными
	// выражениями можно использовать вариант `MustCompile`
	// вместо `Compile`. `MustCompile` вызывает panic вместо
	// возврата ошибки, что делает его безопаснее для использования
	// с глобальными переменными.
	r = regexp.MustCompile("p([a-z]+)ch")
	fmt.Println("regexp:", r)

	// Пакет `regexp` также можно использовать для замены
	// подстрок другими значениями.
	fmt.Println(r.ReplaceAllString("a peach", "<fruit>"))

	// Вариант `Func` позволяет преобразовывать совпавший
	// текст с помощью заданной функции.
	in := []byte("a peach")
	out := r.ReplaceAllFunc(in, bytes.ToUpper)
	fmt.Println(string(out))
}
