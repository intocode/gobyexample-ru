// Go позволяет _восстановиться_ после паники с помощью
// встроенной функции `recover`. `recover` может остановить
// `panic` и позволить программе продолжить выполнение.

// Пример полезного применения: сервер не должен падать,
// если одно из клиентских соединений вызывает критическую
// ошибку. Вместо этого сервер должен закрыть это соединение
// и продолжить обслуживать других клиентов. Именно так
// по умолчанию работает `net/http` в Go для HTTP-серверов.

package main

import "fmt"

// Эта функция вызывает panic.
func mayPanic() {
	panic("a problem")
}

func main() {
	// `recover` должен вызываться внутри отложенной функции.
	// Когда охватывающая функция паникует, defer активируется,
	// и вызов `recover` внутри него перехватит панику.
	defer func() {
		if r := recover(); r != nil {
			// Возвращаемое значение `recover` — это ошибка,
			// переданная в вызов `panic`.
			fmt.Println("Recovered. Error:\n", r)
		}
	}()

	mayPanic()

	// Этот код не выполнится, потому что `mayPanic` паникует.
	// Выполнение `main` останавливается в момент паники
	// и продолжается в отложенном замыкании.
	fmt.Println("After mayPanic()")
}
