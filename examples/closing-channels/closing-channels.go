// _Закрытие_ канала означает, что в него больше не будут
// отправляться значения. Это полезно для сообщения
// получателям канала о завершении работы.

package main

import "fmt"

// В этом примере мы используем канал `jobs` для передачи
// задач из горутины `main()` в горутину-воркер. Когда
// задач для воркера больше нет, мы закроем канал `jobs`
// с помощью `close`.
func main() {
	jobs := make(chan int, 5)
	done := make(chan bool)

	// Вот горутина-воркер. Она многократно получает данные
	// из `jobs` с помощью `j, more := <-jobs`. В этой
	// специальной форме получения с двумя значениями
	// `more` будет равно `false`, если канал `jobs` был
	// закрыт и все значения из него уже получены.
	// Мы используем это, чтобы отправить уведомление в `done`,
	// когда все задачи выполнены.
	go func() {
		for {
			j, more := <-jobs
			if more {
				fmt.Println("received job", j)
			} else {
				fmt.Println("received all jobs")
				done <- true
				return
			}
		}
	}()

	// Здесь мы отправляем 3 задачи воркеру через канал
	// `jobs`, а затем закрываем его.
	for j := 1; j <= 3; j++ {
		jobs <- j
		fmt.Println("sent job", j)
	}
	close(jobs)
	fmt.Println("sent all jobs")

	// Ожидаем воркера, используя подход
	// [синхронизации](channel-synchronization), который
	// мы видели ранее.
	<-done

	// Чтение из закрытого канала выполняется немедленно
	// и возвращает нулевое значение соответствующего типа.
	// Опциональное второе возвращаемое значение равно `true`,
	// если полученное значение было доставлено успешной
	// операцией отправки в канал, или `false`, если это
	// нулевое значение, сгенерированное потому, что канал
	// закрыт и пуст.
	_, ok := <-jobs
	fmt.Println("received more jobs:", ok)
}
